use std::marker::PhantomData;

use crate::{
    field::RandomField,
    sumcheck::SumcheckProof,
    zip::{code::ZipSpec, pcs::structs::MultilinearZipCommitment},
};

/// Non-interactive proof generated by the Spartan prover
///
/// # Members
///
/// * `linearization_sumcheck` - A list of non-interactive sumcheck prover messages for the linearization sumcheck.
/// * `second_sumcheck` - A list of non-interactive sumcheck prover messages for the second sumcheck.
/// * `V_s` - The MLEs of $\\{ M_j \mathbf{z} \mid j = 1, 2, \dots, t \\}$ evaluated at sumcheck challenge point.
#[derive(Debug, Clone)]
pub struct SpartanProof<const N: usize> {
    /// A list of non-interactive sumcheck prover messages.  
    ///
    /// Sent in step 2 of linearization subprotocol.  
    pub sumcheck_proof_1: SumcheckProof<N>,
    /// A list of non-interactive sumcheck prover messages.  
    ///
    /// Sent in step 3 of linearization subprotocol.  
    pub sumcheck_proof_2: SumcheckProof<N>,
    /// The MLEs of $\\{ M_j \mathbf{z} \mid j = 1, 2, \dots, t \\}$ evaluated at sumcheck challenge point.  
    pub V_s: Vec<RandomField<N>>,
}

pub struct ZipProof<const N: usize> {
    /// A commitment to the roots of the merkle tree of each row of the polynomial matrix representation.
    pub z_comm: MultilinearZipCommitment<N>,
    pub v: RandomField<N>,
    pub pcs_proof: Vec<u8>,
}

pub struct LookupProof<const N: usize> {}

pub struct ZincProof<const N: usize> {
    pub spartan_proof: SpartanProof<N>,
    pub zip_proof: ZipProof<N>,
    pub lookup_proof: Option<LookupProof<N>>,
}

/// The implementation of the `ZincProver` trait is defined in the main prover file.
pub struct ZincProver<const N: usize, S>
where
    S: ZipSpec,
{
    pub data: PhantomData<S>,
}

/// The implementation of the `ZincVerifier` trait is defined in the main verifier file.
pub struct ZincVerifier<const N: usize, S>
where
    S: ZipSpec,
{
    pub data: PhantomData<S>,
}
