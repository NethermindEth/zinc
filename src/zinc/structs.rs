use ark_std::{marker::PhantomData, vec::Vec};

use crate::{
    sumcheck,
    traits::{Field, ZipTypes},
    zip::{code::LinearCodeSpec, pcs::structs::MultilinearZipCommitment},
};

/// Non-interactive proof generated by the linearization prover
///
/// # Members
///
/// * `linearization_sumcheck` - A list of non-interactive sumcheck prover messages.
/// * `v` - The MLE of `wit.f_hat` evaluated at the sumcheck challenge point.
/// * `u` - The MLEs of $\\{ M_j \mathbf{z} \mid j = 1, 2, \dots, t \\}$ evaluated at sumcheck challenge point.
#[derive(Debug, Clone)]
pub struct SpartanProof<F> {
    /// A list of non-interactive sumcheck prover messages.  
    ///
    /// Sent in step 2 of linearization subprotocol.  
    pub linearization_sumcheck: sumcheck::SumcheckProof<F>,
    pub second_sumcheck: sumcheck::SumcheckProof<F>,
    pub V_s: Vec<F>,
}

pub struct ZipProof<F> {
    pub z_comm: MultilinearZipCommitment,
    pub v: F,
    pub pcs_proof: Vec<u8>,
}

pub struct ZincProof<F> {
    pub spartan_proof: SpartanProof<F>,
    pub zip_proof: ZipProof<F>,
}

/// The implementation of the `LinearizationProver` trait is defined in the main linearization file.
pub struct ZincProver<ZT: ZipTypes, F: Field, S: LinearCodeSpec> {
    pub lc_spec: S,
    phantom_data: PhantomData<(ZT, F)>,
}

impl<ZT: ZipTypes, F: Field, S: LinearCodeSpec> ZincProver<ZT, F, S> {
    pub fn new(lc_spec: S) -> Self {
        ZincProver {
            lc_spec,
            phantom_data: PhantomData,
        }
    }
}

/// The implementation of the `LinearizationVerifier` trait is defined in the main linearization file.
pub struct ZincVerifier<ZT: ZipTypes, F: Field, S: LinearCodeSpec> {
    pub lc_spec: S,
    phantom_data: PhantomData<(ZT, F, S)>,
}

impl<ZT: ZipTypes, F: Field, S: LinearCodeSpec> ZincVerifier<ZT, F, S> {
    pub fn new(lc_spec: S) -> Self {
        ZincVerifier {
            lc_spec,
            phantom_data: PhantomData,
        }
    }
}
