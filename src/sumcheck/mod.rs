use ark_std::{boxed::Box, marker::PhantomData, vec::Vec};
use prover::{ProverMsg, ProverState};
use thiserror::Error;

use self::verifier::SubClaim;
use crate::{
    poly::ArithErrors,
    poly_f::mle::DenseMultilinearExtension,
    traits::{Field, FieldMap, Words},
    transcript::KeccakTranscript as Transcript,
};

pub mod prover;
pub mod utils;
pub mod verifier;

/// Interactive Proof for Multilinear Sumcheck
pub struct IPForMLSumcheck<F>(PhantomData<F>);
#[derive(Error, Debug)]
pub enum SumCheckError<F: Field> {
    #[error("univariate polynomial evaluation error")]
    EvaluationError(ArithErrors),
    #[error("incorrect sumcheck sum. Expected `{0}`. Received `{1}`")]
    SumCheckFailed(Box<F::DebugField>, Box<F::DebugField>),
    #[error("max degree exceeded")]
    MaxDegreeExceeded,
}

impl<F: Field> From<ArithErrors> for SumCheckError<F> {
    fn from(arith_error: ArithErrors) -> Self {
        Self::EvaluationError(arith_error)
    }
}

/// Sumcheck for products of multilinear polynomial
pub struct MLSumcheck<F: Field>(#[doc(hidden)] (F, Transcript));

/// proof generated by prover
#[derive(Clone, Debug, PartialEq)]
pub struct SumcheckProof<F>(Vec<ProverMsg<F>>);

impl<F: Field> MLSumcheck<F> {
    /// extract sum from the proof
    pub fn extract_sum(proof: &SumcheckProof<F>) -> F {
        proof.0[0].evaluations[0].clone() + proof.0[0].evaluations[1].clone()
    }

    /// This function does the same thing as `prove`, but it uses cryptographic sponge as the transcript/to generate the
    /// verifier challenges. Additionally, it returns the prover's state in addition to the proof.
    /// Both of these allow this sumcheck to be better used as a part of a larger protocol.
    pub fn prove_as_subprotocol(
        transcript: &mut Transcript,
        mles: Vec<DenseMultilinearExtension<F>>,
        nvars: usize,
        degree: usize,
        comb_fn: impl Fn(&[F]) -> F + Send + Sync,
        config: F::R,
    ) -> (SumcheckProof<F>, ProverState<F>) {
        let (nvars_field, degree_field): (F, F) = if F::W::num_words() == 1 {
            (
                (nvars as u64).map_to_field(config),
                (degree as u64).map_to_field(config),
            )
        } else {
            (
                (nvars as u128).map_to_field(config),
                (degree as u128).map_to_field(config),
            )
        };
        transcript.absorb_random_field(&nvars_field);
        transcript.absorb_random_field(&degree_field);
        let mut prover_state = IPForMLSumcheck::prover_init(mles, nvars, degree);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(nvars);

        for _ in 0..nvars {
            let prover_msg =
                IPForMLSumcheck::prove_round(&mut prover_state, &verifier_msg, &comb_fn, config);
            transcript.absorb_slice(&prover_msg.evaluations);
            prover_msgs.push(prover_msg);
            let next_verifier_msg = IPForMLSumcheck::sample_round(transcript, config);
            transcript.absorb_random_field(&next_verifier_msg.randomness);

            verifier_msg = Some(next_verifier_msg);
        }
        prover_state
            .randomness
            .push(verifier_msg.unwrap().randomness);

        (SumcheckProof(prover_msgs), prover_state)
    }

    /// This function does the same thing as `prove`, but it uses a cryptographic sponge as the transcript/to generate the
    /// verifier challenges. This allows this sumcheck to be used as a part of a larger protocol.
    pub fn verify_as_subprotocol(
        transcript: &mut Transcript,
        nvars: usize,
        degree: usize,
        claimed_sum: F,
        proof: &SumcheckProof<F>,
        config: F::R,
    ) -> Result<SubClaim<F>, SumCheckError<F>> {
        let (nvars_field, degree_field): (F, F) = if F::W::num_words() == 1 {
            (
                (nvars as u64).map_to_field(config),
                (degree as u64).map_to_field(config),
            )
        } else {
            (
                (nvars as u128).map_to_field(config),
                (degree as u128).map_to_field(config),
            )
        };
        transcript.absorb_random_field(&nvars_field);
        transcript.absorb_random_field(&degree_field);
        let mut verifier_state = IPForMLSumcheck::verifier_init(nvars, degree, config);
        for i in 0..nvars {
            let prover_msg = proof.0.get(i).expect("proof is incomplete");
            transcript.absorb_slice(&prover_msg.evaluations);
            let verifier_msg =
                IPForMLSumcheck::verify_round(prover_msg.clone(), &mut verifier_state, transcript);
            transcript.absorb_random_field(&verifier_msg.randomness);
        }

        IPForMLSumcheck::check_and_generate_subclaim(verifier_state, claimed_sum, config)
    }
}

#[cfg(test)]
mod tests {

    use ark_std::{rand, str::FromStr};
    use rand::Rng;

    use super::{
        utils::{rand_poly, rand_poly_comb_fn},
        MLSumcheck, SumcheckProof,
    };
    use crate::{
        biginteger::BigInt,
        field::RandomField,
        field_config::{ConfigRef, FieldConfig},
        traits::{Config, ConfigReference, Field},
        transcript::KeccakTranscript,
    };

    fn generate_sumcheck_proof<F: Field>(
        nvars: usize,
        mut rng: &mut (impl Rng + Sized),
        config: F::R,
    ) -> (usize, F, SumcheckProof<F>) {
        let mut transcript = KeccakTranscript::default();

        let ((poly_mles, poly_degree), products, sum) =
            rand_poly(nvars, (2, 5), 7, config, &mut rng).unwrap();

        let comb_fn = |vals: &[F]| -> F { rand_poly_comb_fn(vals, &products, config) };

        let (proof, _) = MLSumcheck::prove_as_subprotocol(
            &mut transcript,
            poly_mles,
            nvars,
            poly_degree,
            comb_fn,
            config,
        );
        (poly_degree, sum, proof)
    }
    #[test]
    fn test_sumcheck() {
        const N: usize = 2;
        let mut rng = ark_std::test_rng();
        let nvars = 3;
        let config = FieldConfig::new(BigInt::from_str("57316695564490278656402085503").unwrap());

        let config_ptr = ConfigRef::from(&config);
        config_ptr.reference().expect("FieldConfig cannot be null");
        for _ in 0..20 {
            let (poly_degree, sum, proof) =
                generate_sumcheck_proof::<RandomField<N>>(nvars, &mut rng, config_ptr);

            let mut transcript = KeccakTranscript::default();
            let res = MLSumcheck::verify_as_subprotocol(
                &mut transcript,
                nvars,
                poly_degree,
                sum,
                &proof,
                config_ptr,
            );
            assert!(res.is_ok())
        }
    }
}
