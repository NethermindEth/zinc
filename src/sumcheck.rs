use ark_std::marker::PhantomData;

use thiserror::Error;

use crate::{field::RandomField, transcript::KeccakTranscript as Transcript};
use prover::{ProverMsg, ProverState};
use verifier::SubClaim;

pub mod prover;
pub mod verifier;

/// Interactive Proof for Multilinear Sumcheck
pub struct IPForMLSumcheck<const N: usize> {
    #[doc(hidden)]
    _marker: PhantomData<(RandomField<N>, Transcript)>,
}

#[derive(Error, Debug)]
pub enum SumCheckError<const N: usize> {
    #[error("univariate polynomial evaluation error")]
    EvaluationError,
    #[error("incorrect sumcheck sum. Expected `{0}`. Received `{1}`")]
    SumCheckFailed(RandomField<N>, RandomField<N>),
    #[error("max degree exceeded")]
    MaxDegreeExceeded,
}

/// Sumcheck for products of multilinear polynomial
pub struct MLSumcheck<const N: usize>(#[doc(hidden)] (RandomField<N>, Transcript));

/// proof generated by prover
#[derive(Clone, Debug, PartialEq)]
pub struct Proof<const N: usize>(Vec<ProverMsg<N>>);

impl<const N: usize> MLSumcheck<N> {
    /// extract sum from the proof
    pub fn extract_sum(proof: &Proof<N>) -> RandomField<N> {
        proof.0[0].evaluations[0] + proof.0[0].evaluations[1]
    }

    /// This function does the same thing as `prove`, but it uses cryptographic sponge as the transcript/to generate the
    /// verifier challenges. Additionally, it returns the prover's state in addition to the proof.
    /// Both of these allow this sumcheck to be better used as a part of a larger protocol.
    pub fn prove_as_subprotocol(
        transcript: &mut Transcript,
        polynomial: &VirtualPolynomial<R>,
    ) -> (Proof<N>, ProverState<N>) {
        // TODO: return this back
        // transcript.absorb(&polynomial.info());

        let mut prover_state = IPForMLSumcheck::prover_init(polynomial);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(polynomial.aux_info.num_variables);
        for _ in 0..polynomial.aux_info.num_variables {
            let prover_msg = IPForMLSumcheck::prove_round(&mut prover_state, &verifier_msg);
            transcript.absorb_slice(&prover_msg.evaluations);
            prover_msgs.push(prover_msg);
            let next_verifier_msg = IPForMLSumcheck::sample_round(transcript);
            transcript.absorb(&next_verifier_msg.randomness.into());

            verifier_msg = Some(next_verifier_msg);
        }
        prover_state
            .randomness
            .push(verifier_msg.unwrap().randomness);

        (Proof(prover_msgs), prover_state)
    }

    /// This function does the same thing as `prove`, but it uses a cryptographic sponge as the transcript/to generate the
    /// verifier challenges. This allows this sumcheck to be used as a part of a larger protocol.
    pub fn verify_as_subprotocol(
        transcript: &mut Transcript,
        polynomial_info: &VPAuxInfo<R>,
        claimed_sum: RandomField<N>,
        proof: &Proof<N>,
    ) -> Result<SubClaim<N>, SumCheckError<N>> {
        // TODO: bring this back
        //transcript.absorb(polynomial_info);

        let mut verifier_state = IPForMLSumcheck::verifier_init(polynomial_info);
        for i in 0..polynomial_info.num_variables {
            let prover_msg = proof.0.get(i).expect("proof is incomplete");
            transcript.absorb_slice(&prover_msg.evaluations);
            let verifier_msg = IPForMLSumcheck::verify_round(
                (*prover_msg).clone(),
                &mut verifier_state,
                transcript,
            );
            transcript.absorb(&verifier_msg.randomness.into());
        }

        IPForMLSumcheck::check_and_generate_subclaim(verifier_state, claimed_sum)
    }
}
