use ark_std::{marker::PhantomData, vec::Vec};

use crate::{
    sumcheck,
    traits::{Field, Integer},
    zip::{code::ZipSpec, pcs::structs::MultilinearZipCommitment},
};

/// Non-interactive proof generated by the linearization prover
///
/// # Members
///
/// * `linearization_sumcheck` - A list of non-interactive sumcheck prover messages.
/// * `v` - The MLE of `wit.f_hat` evaluated at the sumcheck challenge point.
/// * `u` - The MLEs of $\\{ M_j \mathbf{z} \mid j = 1, 2, \dots, t \\}$ evaluated at sumcheck challenge point.
#[derive(Debug, Clone)]
pub struct SpartanProof<F> {
    /// A list of non-interactive sumcheck prover messages.  
    ///
    /// Sent in step 2 of linearization subprotocol.  
    pub linearization_sumcheck: sumcheck::SumcheckProof<F>,
    pub second_sumcheck: sumcheck::SumcheckProof<F>,
    pub V_s: Vec<F>,
}

pub struct ZipProof<F> {
    pub z_comm: MultilinearZipCommitment,
    pub v: F,
    pub pcs_proof: Vec<u8>,
}

pub struct ZincProof<F> {
    pub spartan_proof: SpartanProof<F>,
    pub zip_proof: ZipProof<F>,
}

/// The implementation of the `LinearizationProver` trait is defined in the main linearization file.
pub struct ZincProver<I: Integer, F: Field, S>
where
    S: ZipSpec,
{
    pub data: PhantomData<(I, F, S)>,
}

/// The implementation of the `LinearizationVerifier` trait is defined in the main linearization file.
pub struct ZincVerifier<I: Integer, F: Field, S>
where
    S: ZipSpec,
{
    pub data: PhantomData<(I, F, S)>,
}
