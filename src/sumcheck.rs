use ark_std::{boxed::Box, marker::PhantomData, string::String, vec::Vec};
use prover::{ProverMsg, ProverState};
use thiserror::Error;

use self::verifier::SubClaim;
use crate::{
    field::RandomField,
    poly::ArithErrors,
    poly_f::mle::DenseMultilinearExtension,
    traits::{ConfigReference, FieldMap},
    transcript::KeccakTranscript as Transcript,
};

pub mod prover;
pub mod utils;
pub mod verifier;

#[cfg(test)]
mod tests;

/// Interactive Proof for Multilinear Sumcheck
pub struct IPForMLSumcheck<C: ConfigReference>(PhantomData<C>);
#[derive(Error, Debug)]
pub enum SumCheckError {
    #[error("univariate polynomial evaluation error")]
    EvaluationError(ArithErrors),
    #[error("incorrect sumcheck sum. Expected `{0}`. Received `{1}`")]
    SumCheckFailed(Box<String>, Box<String>),
    #[error("max degree exceeded")]
    MaxDegreeExceeded,
    #[error("invalid proof length: expected {expected}, got {got}")]
    InvalidProofLength { expected: usize, got: usize },
}

impl From<ArithErrors> for SumCheckError {
    fn from(arith_error: ArithErrors) -> Self {
        Self::EvaluationError(arith_error)
    }
}

/// Sumcheck for products of multilinear polynomial
pub struct MLSumcheck<C: ConfigReference>((RandomField<C>, Transcript));

/// proof generated by prover
#[derive(Clone, Debug, PartialEq)]
pub struct SumcheckProof<C: ConfigReference>(pub Vec<ProverMsg<C>>);

impl<C: ConfigReference> MLSumcheck<C> {
    /// extract sum from the proof
    pub fn extract_sum(proof: &SumcheckProof<C>) -> RandomField<C> {
        proof.0[0].evaluations[0].clone() + proof.0[0].evaluations[1].clone()
    }

    /// This function does the same thing as `prove`, but it uses cryptographic sponge as the transcript/to generate the
    /// verifier challenges. Additionally, it returns the prover's state in addition to the proof.
    /// Both of these allow this sumcheck to be better used as a part of a larger protocol.
    pub fn prove_as_subprotocol(
        transcript: &mut Transcript,
        mles: Vec<DenseMultilinearExtension<C>>,
        nvars: usize,
        degree: usize,
        comb_fn: impl Fn(&[RandomField<C>]) -> RandomField<C> + Send + Sync,
        config: C,
    ) -> (SumcheckProof<C>, ProverState<C>) {
        let (nvars_field, degree_field): (RandomField<C>, RandomField<C>) = if C::N == 1 {
            (
                (nvars as u64).map_to_field(config),
                (degree as u64).map_to_field(config),
            )
        } else {
            (
                (nvars as u128).map_to_field(config),
                (degree as u128).map_to_field(config),
            )
        };
        transcript.absorb_random_field(&nvars_field);
        transcript.absorb_random_field(&degree_field);
        if nvars == 0 {
            let base_vals: Vec<RandomField<C>> = mles
                .iter()
                .map(|m| m.evaluate(&[], config).expect("eval at empty point"))
                .collect();
            let _sum_at_empty = comb_fn(&base_vals);

            let prover_state = ProverState {
                randomness: Vec::new(),
                mles,
                num_vars: 0,
                max_degree: degree,
                round: 0,
            };
            return (SumcheckProof(Vec::new()), prover_state);
        }
        let mut prover_state = IPForMLSumcheck::prover_init(mles, nvars, degree);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(nvars);

        for _ in 0..nvars {
            let prover_msg =
                IPForMLSumcheck::prove_round(&mut prover_state, &verifier_msg, &comb_fn, config);
            transcript.absorb_slice(&prover_msg.evaluations);
            prover_msgs.push(prover_msg);
            let next_verifier_msg = IPForMLSumcheck::sample_round(transcript, config);
            transcript.absorb_random_field(&next_verifier_msg.randomness);

            verifier_msg = Some(next_verifier_msg);
        }
        if let Some(vmsg) = verifier_msg {
            prover_state.randomness.push(vmsg.randomness);
        }

        (SumcheckProof(prover_msgs), prover_state)
    }

    /// This function does the same thing as `prove`, but it uses a cryptographic sponge as the transcript/to generate the
    /// verifier challenges. This allows this sumcheck to be used as a part of a larger protocol.
    pub fn verify_as_subprotocol(
        transcript: &mut Transcript,
        num_vars: usize,
        degree: usize,
        claimed_sum: RandomField<C>,
        proof: &SumcheckProof<C>,
        config: C,
    ) -> Result<SubClaim<C>, SumCheckError> {
        let (nvars_field, degree_field): (RandomField<C>, RandomField<C>) = if C::N == 1 {
            (
                (num_vars as u64).map_to_field(config),
                (degree as u64).map_to_field(config),
            )
        } else {
            (
                (num_vars as u128).map_to_field(config),
                (degree as u128).map_to_field(config),
            )
        };
        transcript.absorb_random_field(&nvars_field);
        transcript.absorb_random_field(&degree_field);

        if num_vars == 0 {
            transcript.absorb_random_field(&claimed_sum);
            return Ok(SubClaim {
                point: Vec::new(),                // empty point
                expected_evaluation: claimed_sum, // f(âˆ…)
            });
        }

        if proof.0.len() != num_vars {
            return Err(SumCheckError::InvalidProofLength {
                expected: num_vars,
                got: proof.0.len(),
            });
        }

        let mut verifier_state = IPForMLSumcheck::verifier_init(num_vars, degree, config);

        for i in 0..num_vars {
            let prover_msg = &proof.0[i];
            transcript.absorb_slice(&prover_msg.evaluations);
            let verifier_msg =
                IPForMLSumcheck::verify_round(prover_msg, &mut verifier_state, transcript);
            transcript.absorb_random_field(&verifier_msg.randomness);
        }

        IPForMLSumcheck::check_and_generate_subclaim(verifier_state, claimed_sum, config)
    }
}
