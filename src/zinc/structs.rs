use std::marker::PhantomData;

use crate::{
    field::RandomField,
    sumcheck,
    zip::{code::ZipSpec, pcs::structs::MultilinearZipCommitment},
};

/// Non-interactive proof generated by the linearization prover
///
/// # Members
///
/// * `linearization_sumcheck` - A list of non-interactive sumcheck prover messages.
/// * `v` - The MLE of `wit.f_hat` evaluated at the sumcheck challenge point.
/// * `u` - The MLEs of $\\{ M_j \mathbf{z} \mid j = 1, 2, \dots, t \\}$ evaluated at sumcheck challenge point.
#[derive(Debug, Clone)]
pub struct SpartanProof<'cfg, const N: usize> {
    /// A list of non-interactive sumcheck prover messages.  
    ///
    /// Sent in step 2 of linearization subprotocol.  
    pub linearization_sumcheck: sumcheck::SumcheckProof<'cfg, N>,
    pub second_sumcheck: sumcheck::SumcheckProof<'cfg, N>,
    pub V_s: Vec<RandomField<'cfg, N>>,
}

pub struct ZipProof<'cfg, const I: usize, const N: usize> {
    pub z_comm: MultilinearZipCommitment<I>,
    pub v: RandomField<'cfg, N>,
    pub pcs_proof: Vec<u8>,
}

pub struct ZincProof<'cfg, const I: usize, const N: usize> {
    pub spartan_proof: SpartanProof<'cfg, N>,
    pub zip_proof: ZipProof<'cfg, I, N>,
}

/// The implementation of the `LinearizationProver` trait is defined in the main linearization file.
pub struct ZincProver<const I: usize, const N: usize, S>
where
    S: ZipSpec,
{
    pub data: PhantomData<S>,
}

/// The implementation of the `LinearizationVerifier` trait is defined in the main linearization file.
pub struct ZincVerifier<const I: usize, const N: usize, S>
where
    S: ZipSpec,
{
    pub data: PhantomData<S>,
}
