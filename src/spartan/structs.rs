use std::marker::PhantomData;

use crate::{
    zip::{code::ZipSpec, pcs::structs::MultilinearZipCommitment},
    field::RandomField,
    field_config::FieldConfig,
    sumcheck,
};

/// Non-interactive proof generated by the linearization prover
///
/// # Members
///
/// * `linearization_sumcheck` - A list of non-interactive sumcheck prover messages.
/// * `v` - The MLE of `wit.f_hat` evaluated at the sumcheck challenge point.
/// * `u` - The MLEs of $\\{ M_j \mathbf{z} \mid j = 1, 2, \dots, t \\}$ evaluated at sumcheck challenge point.
pub struct SpartanProof<const N: usize> {
    /// A list of non-interactive sumcheck prover messages.  
    ///
    /// Sent in step 2 of linearization subprotocol.  
    pub linearization_sumcheck: sumcheck::Proof<N>,
    pub second_sumcheck: sumcheck::Proof<N>,
    pub V_s: Vec<RandomField<N>>,
    pub v: RandomField<N>,
    pub z_comm: MultilinearZipCommitment<N>,
    pub pcs_proof: Vec<u8>,
}

/// The implementation of the `LinearizationProver` trait is defined in the main linearization file.
pub struct ZincProver<const N: usize, S>
where
    S: ZipSpec,
{
    pub config: *const FieldConfig<N>,
    pub data: PhantomData<S>,
}

/// The implementation of the `LinearizationVerifier` trait is defined in the main linearization file.
pub struct ZincVerifier<const N: usize, S>
where
    S: ZipSpec,
{
    pub config: *const FieldConfig<N>,
    pub data: PhantomData<S>,
}
